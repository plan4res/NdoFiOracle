/*--------------------------------------------------------------------------*/
/*----------------------------- File LukFiOrcl.C ---------------------------*/
/*--------------------------------------------------------------------------*/
/** @file
 *
 * Implementation of the LukFiOrcl class, which implements the FiOracle
 * interface and provides a set of 25 test problems for nonsmmoth
 * unconstrained optimization.
 *
 * \author  Annabella Astorino \n
 *          Istituto di Calcolo e Reti ad Alte Prestazioni - CNR \n
 *
 * \author  Antonio Frangioni \n
 *          Dipartimento di Informatica \n
 *          Universita' di Pisa \n
 *
 * \author  Manlio Gaudioso \n
 *          Dipartimento di Elettronica Informatica e Sistemistica \n
 *          Universita' della Calabria \n
 *
 * \author  Enrico Gorgone \n
 *          Dipartimento di Elettronica Informatica e Sistemistica \n
 *          Universita' della Calabria \n
 *
 * \copyright &copy; by Antonio Frangioni, Enrico Gorgone
 */
/*--------------------------------------------------------------------------*/
/*--------------------------- IMPLEMENTATION -------------------------------*/
/*--------------------------------------------------------------------------*/
/*------------------------------ INCLUDES ----------------------------------*/
/*--------------------------------------------------------------------------*/

#include "LukFiOrcl.h"

#include "OPTvect.h"

#include <stdlib.h>

#include <cmath>
#include <algorithm>

#include <random>

/*--------------------------------------------------------------------------*/
/*-------------------------------- USING -----------------------------------*/
/*--------------------------------------------------------------------------*/

using namespace NDO_di_unipi_it;

/*--------------------------------------------------------------------------*/
/*-------------------------------- USING -----------------------------------*/
/*--------------------------------------------------------------------------*/

static cIndex EmptySg = Inf< Index >();

/*--------------------------------------------------------------------------*/

double A12[ 10 ][ 5 ] = { { 0 , 0 , 0 , 0 , 0 } , { 2 , 1 , 1 , 1 , 3 } ,
                          { 1 , 2 , 1 , 1 , 2 } , { 1 , 4 , 1 , 2 , 2 } ,
			  { 3 , 2 , 1 , 0 , 1 } , { 0 , 2 , 1 , 0 , 1 } ,
			  { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 1 , 2 , 1 } ,
			  { 0 , 0 , 2 , 1 , 0 } , { 1 , 1 , 2 , 0 , 0 } };
double b12[ 10 ] = { 1 , 5 , 10 , 2 , 4 , 3 , 1.7 , 2.5 , 6 , 3.5 };

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

double A13[ 10 ][ 5 ] = { {-16 , 2 , 0 , 1 , 0} , { 0 , -2 , 0 , 4 , 2} ,
 {-3.5 , 0 , 2 , 0 , 0} , {0 , -2 , 0 , -4 , -1} , {0 , -9 , -2 , 1 , -2.8} ,
 {2 , 0 , -4 , 0 , 0} , {-1 , -1 , -1 , -1 , -1} , {-1 , -2 , -3 , -2 , -1} ,
 {1 , 2, 3 , 4 , 5} , {1 , 1 , 1 , 1 , 1} };
double b13[ 10 ] = { -40 , -2 , -0.25 , -4 , -4 , -1 , -40 , -60 , 5 , 1};
double C13[ 5 ][ 5 ] = { {30 , -20 , -10 , 32 , -10} , {-20 , 39, -6 , -31 ,
 32 } , {-10 , -6 , 10 , -6 , -10} , {32 , -31 , -6 , 39 , -20} ,
 {-10 , 32 , -10 , -20 , 30} };
double d13[ 5 ] = { 4 , 8 , 10 , 6 , 2 };
double e13[ 5 ] = { -15 , -27 , -36 , -18 , -12 };

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

double A21[ 48 ][ 48 ] = {
 { 100000 , 273 , 1272 , 744 , 1138 , 1972 , 1580 , 1878 , 1539 , 1457 , 429 , 1129 , 1251 , 1421 , 588 , 334 , 837 , 1364 , 229 , 961 , 754 , 1169 , 1488 , 720 , 1280 , 816 , 664 , 1178 , 939 , 1698 , 983 , 1119 , 1029 , 1815 , 721 , 1753 , 330 , 1499 , 1107 , 1576 , 942 , 484 , 617 , 896 , 1184 , 1030 , 1718 , 604 } ,
 { 273 , 100000 , 999 , 809 , 866 , 1722 , 1338 , 1640 , 1266 , 1185 , 440 , 894 , 992 , 1173 , 334 , 358 , 626 , 1124 , 358 , 847 , 533 , 915 , 1219 , 481 , 1009 , 543 , 937 , 915 , 667 , 1441 , 812 , 848 , 776 , 1560 , 526 , 1494 , 598 , 1244 , 1304 , 1306 , 685 , 668 , 444 , 1157 , 1359 , 1176 , 1475 , 335 } ,
 { 1272 , 999 , 100000 , 1519 , 140 , 937 , 697 , 951 , 267 , 227 , 1229 , 587 , 369 , 554 , 721 , 1212 , 739 , 596 , 1291 , 1114 , 701 , 426 , 285 , 676 , 155 , 456 , 1936 , 319 , 337 , 604 , 907 , 214 , 424 , 748 , 817 , 666 , 1592 , 521 , 2172 , 356 , 467 , 1583 , 882 , 2139 , 2182 , 1961 , 781 , 678 } ,
 { 744 , 809 , 1519 , 100000 , 1425 , 1861 , 1473 , 1713 , 1761 , 1617 , 370 , 1073 , 1304 , 1369 , 1092 , 453 , 798 , 1283 , 973 , 565 , 1315 , 1204 , 1796 , 846 , 1447 , 1143 , 959 , 1275 , 1213 , 2085 , 742 , 1309 , 1479 , 1760 , 703 , 1727 , 872 , 1479 , 686 , 1698 , 1057 , 387 , 1252 , 904 , 668 , 443 , 1600 , 930 } ,
 { 1138 , 866 , 140 , 1425 , 100000 , 1052 , 776 , 1049 , 402 , 361 , 1119 , 578 , 406 , 618 , 581 , 1095 , 670 , 641 , 1152 , 1060 , 567 , 433 , 374 , 579 , 235 , 325 , 1802 , 331 , 217 , 665 , 862 , 182 , 312 , 864 , 732 , 783 , 1456 , 608 , 2066 , 491 , 400 , 1466 , 744 , 2013 , 2082 , 1865 , 875 , 552 } ,
 { 1972 , 1722 , 937 , 1861 , 1052 , 100000 , 400 , 182 , 820 , 721 , 1735 , 851 , 740 , 551 , 1551 , 1769 , 1159 , 613 , 2072 , 1300 , 1605 , 807 , 1017 , 1251 , 818 , 1259 , 2596 , 826 , 1137 , 1255 , 1123 , 943 , 1359 , 188 , 1282 , 271 , 2300 , 483 , 2540 , 609 , 1038 , 2099 , 1766 , 2699 , 2493 , 2266 , 264 , 1398 } ,
 { 1580 , 1338 , 697 , 1473 , 776 , 400 , 100000 , 304 , 699 , 538 , 1335 , 454 , 393 , 173 , 1198 , 1370 , 760 , 216 , 1692 , 919 , 1286 , 435 , 879 , 861 , 548 , 913 , 2198 , 483 , 803 , 1181 , 731 , 627 , 1086 , 292 , 883 , 279 , 1906 , 178 , 2156 , 490 , 662 , 1699 , 1430 , 2300 , 2117 , 1888 , 138 , 1023 } ,
 { 1878 , 1640 , 951 , 1713 , 1049 , 182 , 304 , 100000 , 884 , 755 , 1612 , 749 , 690 , 476 , 1501 , 1654 , 1049 , 516 , 1995 , 1149 , 1580 , 739 , 1079 , 1161 , 815 , 1214 , 2485 , 780 , 1100 , 1347 , 985 , 916 , 1361 , 260 , 1171 , 328 , 2202 , 445 , 2385 , 665 , 966 , 1969 , 1729 , 2568 , 2333 , 2108 , 177 , 1327 } ,
 { 1539 , 1266 , 267 , 1761 , 402 , 820 , 699 , 884 , 100000 , 177 , 1486 , 757 , 506 , 609 , 981 , 1474 , 967 , 681 , 1552 , 1317 , 936 , 594 , 197 , 928 , 316 , 723 , 2203 , 500 , 604 , 482 , 1104 , 455 , 630 , 641 , 1058 , 562 , 1857 , 528 , 2425 , 220 , 704 , 1845 , 1122 , 2405 , 2428 , 2204 , 738 , 945 } ,
 { 1457 , 1185 , 227 , 1617 , 361 , 721 , 538 , 755 , 177 , 100000 , 1362 , 587 , 335 , 435 , 930 , 1358 , 819 , 504 , 1496 , 1153 , 927 , 428 , 341 , 803 , 180 , 649 , 2119 , 343 , 521 , 652 , 939 , 340 , 649 , 533 , 918 , 451 , 1783 , 362 , 2290 , 130 , 568 , 1727 , 1105 , 2301 , 2285 , 2059 , 595 , 853 } ,
 { 429 , 440 , 1229 , 370 , 1119 , 1735 , 1335 , 1612 , 1486 , 1362 , 100000 , 891 , 1082 , 1199 , 726 , 96 , 583 , 1125 , 653 , 563 , 947 , 986 , 1493 , 560 , 1183 , 813 , 882 , 1033 , 902 , 1763 , 642 , 1032 , 1131 , 1604 , 463 , 1556 , 663 , 1298 , 947 , 1461 , 795 , 371 , 882 , 967 , 973 , 768 , 1472 , 588 } ,
 { 1129 , 894 , 587 , 1073 , 578 , 851 , 454 , 749 , 757 , 587 , 891 , 100000 , 252 , 308 , 803 , 920 , 309 , 238 , 1252 , 569 , 940 , 165 , 863 , 414 , 454 , 552 , 1745 , 269 , 482 , 1188 , 355 , 397 , 833 , 713 , 432 , 666 , 1453 , 410 , 1758 , 642 , 262 , 1260 , 1051 , 1858 , 1737 , 1508 , 592 , 598 } ,
 { 1251 , 992 , 369 , 1304 , 406 , 740 , 393 , 690 , 506 , 335 , 1082 , 252 , 100000 , 222 , 814 , 1094 , 510 , 235 , 1335 , 820 , 892 , 100 , 626 , 541 , 219 , 524 , 1897 , 90 , 410 , 952 , 605 , 238 , 706 , 570 , 622 , 503 , 1581 , 257 , 1985 , 396 , 309 , 1453 , 1039 , 2043 , 1972 , 1744 , 514 , 661 } ,
 { 1421 , 1173 , 554 , 1369 , 618 , 551 , 173 , 476 , 609 , 435 , 1199 , 308 , 222 , 100000 , 1025 , 1227 , 617 , 90 , 1525 , 835 , 1114 , 263 , 770 , 700 , 400 , 740 , 2049 , 311 , 630 , 1087 , 630 , 459 , 924 , 405 , 739 , 360 , 1749 , 115 , 2055 , 428 , 492 , 1568 , 1256 , 2166 , 2026 , 1796 , 303 , 853 } ,
 { 588 , 334 , 721 , 1092 , 581 , 1551 , 1198 , 1501 , 981 , 930 , 726 , 803 , 814 , 1025 , 100000 , 663 , 632 , 999 , 572 , 972 , 225 , 763 , 908 , 451 , 767 , 293 , 1240 , 726 , 420 , 1111 , 862 , 617 , 443 , 1374 , 586 , 1299 , 887 , 1070 , 1633 , 1057 , 547 , 999 , 252 , 1483 , 1681 , 1489 , 1326 , 236 } ,
 { 334 , 358 , 1212 , 453 , 1095 , 1769 , 1370 , 1654 , 1474 , 1358 , 96 , 920 , 1094 , 1227 , 663 , 100000 , 610 , 1156 , 557 , 642 , 879 , 1000 , 1467 , 558 , 1178 , 780 , 831 , 1038 , 879 , 1726 , 700 , 1023 , 1082 , 1631 , 488 , 1579 , 586 , 1320 , 982 , 1463 , 796 , 371 , 802 , 949 , 1021 , 826 , 1508 , 550 } ,
 { 837 , 626 , 739 , 798 , 670 , 1159 , 760 , 1049 , 967 , 819 , 583 , 309 , 510 , 617 , 632 , 610 , 100000 , 546 , 983 , 397 , 821 , 411 , 1023 , 180 , 651 , 478 , 1438 , 476 , 485 , 1333 , 235 , 525 , 827 , 1022 , 123 , 973 , 1155 , 715 , 1475 , 902 , 273 , 953 , 882 , 1550 , 1467 , 1240 , 898 , 396 } ,
 { 1364 , 1124 , 596 , 1283 , 641 , 613 , 216 , 516 , 681 , 504 , 1125 , 238 , 235 , 90 , 999 , 1156 , 546 , 100000 , 1479 , 745 , 1105 , 240 , 831 , 645 , 442 , 723 , 1983 , 316 , 623 , 1152 , 543 , 470 , 939 , 482 , 669 , 443 , 1690 , 205 , 1969 , 510 , 455 , 1492 , 1238 , 2091 , 1938 , 1709 , 354 , 813 } ,
 { 229 , 358 , 1291 , 973 , 1152 , 2072 , 1692 , 1995 , 1552 , 1496 , 653 , 1252 , 1335 , 1525 , 572 , 557 , 983 , 1479 , 100000 , 1163 , 676 , 1264 , 1473 , 839 , 1326 , 847 , 801 , 1254 , 976 , 1643 , 1157 , 1169 , 983 , 1905 , 878 , 1836 , 346 , 1590 , 1286 , 1621 , 1034 , 689 , 503 , 995 , 1376 , 1239 , 1828 , 674 } ,
 { 961 , 847 , 1114 , 565 , 1060 , 1300 , 919 , 1149 , 1317 , 1153 , 563 , 569 , 820 , 835 , 972 , 642 , 397 , 745 , 1163 , 100000 , 1183 , 725 , 1399 , 549 , 1004 , 869 , 1427 , 818 , 882 , 1716 , 214 , 902 , 1222 , 1210 , 390 , 1184 , 1225 , 949 , 1239 , 1210 , 660 , 863 , 1207 , 1446 , 1197 , 969 , 1042 , 741 } ,
 { 754 , 533 , 701 , 1315 , 567 , 1605 , 1286 , 1580 , 936 , 927 , 947 , 940 , 892 , 1114 , 225 , 879 , 821 , 1105 , 676 , 1183 , 100000 , 865 , 821 , 644 , 790 , 388 , 1374 , 803 , 484 , 968 , 1056 , 665 , 318 , 1420 , 794 , 1341 , 1017 , 1137 , 1836 , 1056 , 679 , 1200 , 189 , 1645 , 1891 , 1704 , 1403 , 442 } ,
 { 1169 , 915 , 426 , 1204 , 433 , 807 , 435 , 739 , 594 , 428 , 986 , 165 , 100 , 263 , 763 , 1000 , 411 , 240 , 1264 , 725 , 865 , 100000 , 699 , 453 , 290 , 483 , 1809 , 107 , 384 , 1024 , 511 , 251 , 712 , 646 , 525 , 585 , 1499 , 330 , 1885 , 495 , 231 , 1356 , 999 , 1949 , 1872 , 1644 , 567 , 591 } ,
 { 1488 , 1219 , 285 , 1796 , 374 , 1017 , 879 , 1079 , 197 , 341 , 1493 , 863 , 626 , 770 , 908 , 1467 , 1023 , 831 , 1473 , 1399 , 821 , 699 , 100000 , 950 , 410 , 690 , 2147 , 594 , 590 , 326 , 1191 , 499 , 504 , 838 , 1098 , 758 , 1794 , 703 , 2439 , 414 , 751 , 1837 , 1011 , 2374 , 2455 , 2237 , 928 , 921 } ,
 { 720 , 481 , 676 , 846 , 579 , 1251 , 861 , 1161 , 928 , 803 , 560 , 414 , 541 , 700 , 451 , 558 , 180 , 645 , 839 , 549 , 644 , 453 , 950 , 100000 , 624 , 325 , 1356 , 480 , 369 , 1241 , 413 , 473 , 680 , 1097 , 166 , 1038 , 1049 , 781 , 1497 , 905 , 238 , 925 , 702 , 1506 , 1506 , 1287 , 998 , 216 } ,
 { 1280 , 1009 , 155 , 1447 , 235 , 818 , 548 , 815 , 316 , 180 , 1183 , 454 , 219 , 400 , 767 , 1178 , 651 , 442 , 1326 , 1004 , 790 , 290 , 410 , 624 , 100000 , 479 , 1941 , 188 , 350 , 736 , 792 , 161 , 547 , 632 , 745 , 552 , 1607 , 375 , 2115 , 296 , 392 , 1547 , 959 , 2121 , 2114 , 1890 , 641 , 676 } ,
 { 816 , 543 , 456 , 1143 , 325 , 1259 , 913 , 1214 , 723 , 649 , 813 , 552 , 524 , 740 , 293 , 780 , 478 , 723 , 847 , 869 , 388 , 483 , 690 , 325 , 479 , 100000 , 1480 , 435 , 129 , 949 , 708 , 325 , 355 , 1081 , 492 , 1007 , 1137 , 779 , 1759 , 774 , 291 , 1148 , 516 , 1688 , 1785 , 1573 , 1038 , 231 } ,
 { 664 , 937 , 1936 , 959 , 1802 , 2596 , 2198 , 2485 , 2203 , 2119 , 882 , 1745 , 1897 , 2049 , 1240 , 831 , 1438 , 1983 , 801 , 1427 , 1374 , 1809 , 2147 , 1356 , 1941 , 1480 , 100000 , 1829 , 1603 , 2339 , 1524 , 1780 , 1673 , 2421 , 1315 , 2394 , 357 , 2136 , 825 , 2237 , 1589 , 579 , 1204 , 347 , 959 , 940 , 2336 , 1266 } ,
 { 1178 , 915 , 319 , 1275 , 331 , 826 , 483 , 780 , 500 , 343 , 1033 , 269 , 90 , 311 , 726 , 1038 , 476 , 316 , 1254 , 818 , 803 , 107 , 594 , 480 , 188 , 435 , 1829 , 100000 , 320 , 919 , 605 , 154 , 623 , 652 , 580 , 582 , 1508 , 344 , 1950 , 429 , 242 , 1402 , 949 , 1986 , 1943 , 1717 , 603 , 582 } ,
 { 939 , 667 , 337 , 1213 , 217 , 1137 , 803 , 1100 , 604 , 521 , 902 , 482 , 410 , 630 , 420 , 879 , 485 , 623 , 976 , 882 , 484 , 384 , 590 , 369 , 350 , 129 , 1603 , 320 , 100000 , 872 , 699 , 197 , 358 , 957 , 529 , 881 , 1263 , 660 , 1849 , 645 , 240 , 1250 , 631 , 1802 , 1867 , 1650 , 923 , 341 } ,
 { 1698 , 1441 , 604 , 2085 , 665 , 1255 , 1181 , 1347 , 482 , 652 , 1763 , 1188 , 952 , 1087 , 1111 , 1726 , 1333 , 1152 , 1643 , 1716 , 968 , 1024 , 326 , 1241 , 736 , 949 , 2339 , 919 , 872 , 100000 , 1511 , 815 , 669 , 1092 , 1397 , 1019 , 1982 , 1010 , 2708 , 695 , 1061 , 2089 , 1148 , 2594 , 2734 , 2520 , 1212 , 1176 } ,
 { 983 , 812 , 907 , 742 , 862 , 1123 , 731 , 985 , 1104 , 939 , 642 , 355 , 605 , 630 , 862 , 700 , 235 , 543 , 1157 , 214 , 1056 , 511 , 1191 , 413 , 792 , 708 , 1524 , 605 , 699 , 1511 , 100000 , 697 , 1051 , 1018 , 290 , 985 , 1280 , 743 , 1427 , 996 , 466 , 987 , 1110 , 1584 , 1395 , 1166 , 861 , 626 } ,
 { 1119 , 848 , 214 , 1309 , 182 , 943 , 627 , 916 , 455 , 340 , 1032 , 397 , 238 , 459 , 617 , 1023 , 525 , 470 , 1169 , 902 , 665 , 251 , 499 , 473 , 161 , 325 , 1780 , 154 , 197 , 815 , 697 , 100000 , 469 , 761 , 607 , 685 , 1446 , 472 , 1969 , 457 , 254 , 1393 , 823 , 1963 , 1975 , 1752 , 739 , 515 } ,
 { 1029 , 776 , 424 , 1479 , 312 , 1359 , 1086 , 1361 , 630 , 649 , 1131 , 833 , 706 , 924 , 443 , 1082 , 827 , 939 , 983 , 1222 , 318 , 712 , 504 , 680 , 547 , 355 , 1673 , 623 , 358 , 669 , 1051 , 469 , 100000 , 1171 , 847 , 1089 , 1316 , 919 , 2063 , 776 , 598 , 1434 , 507 , 1926 , 2101 , 1898 , 1187 , 548 } ,
 { 1815 , 1560 , 748 , 1760 , 864 , 188 , 292 , 260 , 641 , 533 , 1604 , 713 , 570 , 405 , 1374 , 1631 , 1022 , 482 , 1905 , 1210 , 1420 , 646 , 838 , 1097 , 632 , 1081 , 2421 , 652 , 957 , 1092 , 1018 , 761 , 1171 , 100000 , 1144 , 83 , 2145 , 317 , 2445 , 426 , 875 , 1972 , 1584 , 2571 , 2408 , 2179 , 194 , 1231 } ,
 { 721 , 526 , 817 , 703 , 732 , 1282 , 883 , 1171 , 1058 , 918 , 463 , 432 , 622 , 739 , 586 , 488 , 123 , 669 , 878 , 390 , 794 , 525 , 1098 , 166 , 745 , 492 , 1315 , 580 , 529 , 1397 , 290 , 607 , 847 , 1144 , 100000 , 1094 , 1036 , 836 , 1371 , 1008 , 354 , 833 , 828 , 1429 , 1369 , 1146 , 1021 , 352 } ,
 { 1753 , 1494 , 666 , 1727 , 783 , 271 , 279 , 328 , 562 , 451 , 1556 , 666 , 503 , 360 , 1299 , 1579 , 973 , 443 , 1836 , 1184 , 1341 , 585 , 758 , 1038 , 552 , 1007 , 2394 , 582 , 881 , 1019 , 985 , 685 , 1089 , 83 , 1094 , 100000 , 2083 , 259 , 2412 , 345 , 811 , 1925 , 1507 , 2523 , 2380 , 2151 , 220 , 1163 } ,
 { 330 , 598 , 1592 , 872 , 1456 , 2300 , 1906 , 2202 , 1857 , 1783 , 663 , 1453 , 1581 , 1749 , 887 , 586 , 1155 , 1690 , 346 , 1225 , 1017 , 1499 , 1794 , 1049 , 1607 , 1137 , 357 , 1508 , 1263 , 1982 , 1280 , 1446 , 1316 , 2145 , 1036 , 2083 , 100000 , 1828 , 1005 , 1903 , 1272 , 504 , 849 , 653 , 1114 , 1019 , 2044 , 932 } ,
 { 1499 , 1244 , 521 , 1479 , 608 , 483 , 178 , 445 , 528 , 362 , 1298 , 410 , 257 , 115 , 1070 , 1320 , 715 , 205 , 1590 , 949 , 1137 , 330 , 703 , 781 , 375 , 779 , 2136 , 344 , 660 , 1010 , 743 , 472 , 919 , 317 , 836 , 259 , 1828 , 100000 , 2165 , 330 , 559 , 1668 , 1291 , 2264 , 2138 , 1908 , 268 , 917 } ,
 { 1107 , 1304 , 2172 , 686 , 2066 , 2540 , 2156 , 2385 , 2425 , 2290 , 947 , 1758 , 1985 , 2055 , 1633 , 982 , 1475 , 1969 , 1286 , 1239 , 1836 , 1885 , 2439 , 1497 , 2115 , 1759 , 825 , 1950 , 1849 , 2708 , 1427 , 1969 , 2063 , 2445 , 1371 , 2412 , 1005 , 2165 , 100000 , 2377 , 1723 , 636 , 1720 , 534 , 145 , 290 , 2281 , 1531 } ,
 { 1576 , 1306 , 356 , 1698 , 491 , 609 , 490 , 665 , 220 , 130 , 1461 , 642 , 396 , 428 , 1057 , 1463 , 902 , 510 , 1621 , 1210 , 1056 , 495 , 414 , 905 , 296 , 774 , 2237 , 429 , 645 , 695 , 996 , 457 , 776 , 426 , 1008 , 345 , 1903 , 330 , 2377 , 100000 , 667 , 1829 , 1235 , 2410 , 2367 , 2139 , 519 , 972 } ,
 { 942 , 685 , 467 , 1057 , 400 , 1038 , 662 , 966 , 704 , 568 , 795 , 262 , 309 , 492 , 547 , 796 , 273 , 455 , 1034 , 660 , 679 , 231 , 751 , 238 , 392 , 291 , 1589 , 242 , 240 , 1061 , 466 , 254 , 598 , 875 , 354 , 811 , 1272 , 559 , 1723 , 667 , 100000 , 1162 , 792 , 1744 , 1724 , 1500 , 796 , 361 } ,
 { 484 , 668 , 1583 , 387 , 1466 , 2099 , 1699 , 1969 , 1845 , 1727 , 371 , 1260 , 1453 , 1568 , 999 , 371 , 953 , 1492 , 689 , 863 , 1200 , 1356 , 1837 , 925 , 1547 , 1148 , 579 , 1402 , 1250 , 2089 , 987 , 1393 , 1434 , 1972 , 833 , 1925 , 504 , 1668 , 636 , 1829 , 1162 , 100000 , 1087 , 600 , 701 , 550 , 1835 , 917 } ,
 { 617 , 444 , 882 , 1252 , 744 , 1766 , 1430 , 1729 , 1122 , 1105 , 882 , 1051 , 1039 , 1256 , 252 , 802 , 882 , 1238 , 503 , 1207 , 189 , 999 , 1011 , 702 , 959 , 516 , 1204 , 949 , 631 , 1148 , 1110 , 823 , 507 , 1584 , 828 , 1507 , 849 , 1291 , 1720 , 1235 , 792 , 1087 , 100000 , 1490 , 1787 , 1614 , 1553 , 486 } ,
 { 896 , 1157 , 2139 , 904 , 2013 , 2699 , 2300 , 2568 , 2405 , 2301 , 967 , 1858 , 2043 , 2166 , 1483 , 949 , 1550 , 2091 , 995 , 1446 , 1645 , 1949 , 2374 , 1506 , 2121 , 1688 , 347 , 1986 , 1802 , 2594 , 1584 , 1963 , 1926 , 2571 , 1429 , 2523 , 653 , 2264 , 534 , 2410 , 1744 , 600 , 1490 , 100000 , 678 , 727 , 2435 , 1461 } ,
 { 1184 , 1359 , 2182 , 668 , 2082 , 2493 , 2117 , 2333 , 2428 , 2285 , 973 , 1737 , 1972 , 2026 , 1681 , 1021 , 1467 , 1938 , 1376 , 1197 , 1891 , 1872 , 2455 , 1506 , 2114 , 1785 , 959 , 1943 , 1867 , 2734 , 1395 , 1975 , 2101 , 2408 , 1369 , 2380 , 1114 , 2138 , 145 , 2367 , 1724 , 701 , 1787 , 678 , 100000 , 229 , 2238 , 1560 } ,
 { 1030 , 1176 , 1961 , 443 , 1865 , 2266 , 1888 , 2108 , 2204 , 2059 , 768 , 1508 , 1744 , 1796 , 1489 , 826 , 1240 , 1709 , 1239 , 969 , 1704 , 1644 , 2237 , 1287 , 1890 , 1573 , 940 , 1717 , 1650 , 2520 , 1166 , 1752 , 1898 , 2179 , 1146 , 2151 , 1019 , 1908 , 290 , 2139 , 1500 , 550 , 1614 , 727 , 229 , 100000 , 2010 , 1353 } ,
 { 1718 , 1475 , 781 , 1600 , 875 , 264 , 138 , 177 , 738 , 595 , 1472 , 592 , 514 , 303 , 1326 , 1508 , 898 , 354 , 1828 , 1042 , 1403 , 567 , 928 , 998 , 641 , 1038 , 2336 , 603 , 923 , 1212 , 861 , 739 , 1187 , 194 , 1021 , 220 , 2044 , 268 , 2281 , 519 , 796 , 1835 , 1553 , 2435 , 2238 , 2010 , 100000 , 1157 } ,
 { 604 , 335 , 678 , 930 , 552 , 1398 , 1023 , 1327 , 945 , 853 , 588 , 598 , 661 , 853 , 236 , 550 , 396 , 813 , 674 , 741 , 442 , 591 , 921 , 216 , 676 , 231 , 1266 , 582 , 341 , 1176 , 626 , 515 , 548 , 1231 , 352 , 1163 , 932 , 917 , 1531 , 972 , 361 , 917 , 486 , 1461 , 1560 , 1353 , 1157 , 100000 }
};
double s21[ 48 ] = { 22 , 53 , 64 , 15 , 66 , 37 , 16 ,23 , 67 , 18 , 52 ,
 69 , 17 , 29 , 50 , 13 , 95 , 34 , 59 , 36 , 22 , 94 , 28 , 34 , 36 , 38 ,
 55 , 77 , 45 , 34 , 32 , 58 , 30 , 88 , 74 , 59 , 93 , 54 , 89 , 30 , 79 ,
 46 , 35 , 41 , 99 , 52 , 76 , 93 };
double d21[ 48 ] = { 61 , 67 , 24 , 84 , 13 , 86 , 89 , 46 , 48 , 50 , 74 ,
 75 , 88 , 40 , 29 , 45 , 32 , 21 , 61 , 21 , 51 , 14 , 89 , 79, 38 , 20 ,
 97 , 19 , 10 , 73 , 59 , 92 , 52 , 66 , 89 , 65 , 63 , 47 , 7 , 61 , 87 ,
 19 , 36 , 43 , 9 , 12 , 8 , 67 };

/*--------------------------------------------------------------------------*/
/*--------------------- IMPLEMENTATION OF LukFiOrcl ------------------------*/
/*--------------------------------------------------------------------------*/
/*--------------------------- PUBLIC METHODS -------------------------------*/
/*--------------------------------------------------------------------------*/
/*---------------------------- CONSTRUCTOR ---------------------------------*/
/*--------------------------------------------------------------------------*/

LukFiOrcl::LukFiOrcl( std::istream *iStrm ) : FiOracle()
{
 Index NrVr;   // number of variables

 DfltdSfInpt( iStrm , NameF , Index( 1 ) );
 DfltdSfInpt( iStrm , NrVr , Index( 2 ) );
 DfltdSfInpt( iStrm , NrCmp , Index( 2 ) );
 DfltdSfInpt( iStrm , seed , Index( 1 ) );

 bQR = aQR  = NULL;
 cQR = NULL;

 if( ( NameF < 1 ) || ( NameF > 25 ) )
  throw( NDOException( "LukFiOrcl: wrong function name" ) );

 switch( NameF ) {

  // smooth     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 26 ):
   NumVar = NrVr;
   break;

  // AbsVal     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 27 ):
   NumVar = NrVr;
   break;

  // MaxQR    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 28 ): {
   std::mt19937 rg;
   std::uniform_real_distribution<> dis( 0.0 , 1.0 );

   NumVar = NrVr;
   rg.seed( seed );
   bQR = new Number[ NrCmp ];
   aQR = new Number[ NrCmp ];
   cQR = new LMRow[ NrCmp ];

   // define data - - - - - - - - - - - - - - - - - - - - -
   for( Index j = 0; j < NrCmp; j++ ) {
	bQR[ j ] = 1e+2 * dis( rg );
	aQR[ j ] = 2e+2 * ( dis( rg ) - 0.5 );
	cQR[ j ] = new Number[ NumVar ];
    for( Index i = 0; i < NumVar; i++ )
     cQR[ j ][ i ] = 2e+2 * ( dis( rg ) - 0.5 );
    }

   break;
   }
  default:

   SetDimension();

  } // end( switch )
 } // end( LukFiOrcl::LukFiOrcl )

/*--------------------------------------------------------------------------*/
/*-------------------------- OTHER INITIALIZATIONS -------------------------*/
/*--------------------------------------------------------------------------*/
/*-------------- METHODS FOR READING THE DATA OF THE PROBLEM ---------------*/
/*--------------------------------------------------------------------------*/

void LukFiOrcl::GetInitialPoint( LMRow lmb )
{
 switch( NameF ) {
  // Rosenbrock  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 1 ):
   lmb[ 0 ] = -1.2;
   lmb[ 1 ] = 1.0;
   break;
  // Crescent    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 2 ):
   lmb[ 0 ] = -1.5;
   lmb[ 1 ] = 2.0;
   break;
  // CB2 (Charalambous/Bandler)  - - - - - - - - - - - - - - - - - - - - - - -
  case( 3 ):
   lmb[ 0 ] = 1;
   lmb[ 1 ] = -0.1;
   break;
  // CB3 (Charalambous/Bandler)  - - - - - - - - - - - - - - - - - - - - - - -
  case( 4 ):
   lmb[ 0 ] = 2;
   lmb[ 1 ] = 2;
   break;
  // DEM (Demyanov/Malozemov)  - - - - - - - - - - - - - - - - - - - - - - - -
  case( 5 ):
   lmb[ 0 ] = 1;
   lmb[ 1 ] = 1;
   break;
  // QL    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 6 ):
   lmb[ 0 ] = -1;
   lmb[ 1 ] = 5;
   break;
  // LQ    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 7 ):
   lmb[ 0 ] = -0.5;
   lmb[ 1 ] = -0.5;
   break;
  // Mifflin1      - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 8 ):
   lmb[ 0 ] = 0.8;
   lmb[ 1 ] = 0.6;
   break;
  // Mifflin2      - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 9 ):
   lmb[ 0 ] = -1;
   lmb[ 1 ] = -1;
   break;
  // Wolfe   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 10 ):
   lmb[ 0 ] = 3;
   lmb[ 1 ] = 2;
   break;
  // Rosen   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 11 ):
   for ( Index i = 0; i < NumVar; i++ )
	lmb[ i ] = 0;
   break;
  // Shor    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 12 ):
   lmb[ 0 ] = 0;  lmb[ 1 ] = 0;  lmb[ 2 ] = 0;  lmb[ 3 ] = 0;  lmb[ 4 ] = 1;
   break;
  // Maxquad   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 13 ):
   for ( Index i = 0; i < NumVar; i++ )
	lmb[ i ] = 1;
   break;
  // Maxq    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 14 ):
   for ( Index i = 0; i < 10; i++ )
	lmb[ i ] = ( i + 1 );
   for ( Index i = 10; i < 20; i++ )
  	lmb[ i ] = - int( i + 1 );
   break;
  // Maxl    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 15 ):
   for ( Index i = 0; i < 10; i++ )
	lmb[ i ] = ( i + 1);
   for( Index i = 10; i < 20; i++ )
 	lmb[ i ] = -int( i +1 );
   break;
  // TR48    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 16 ):
   for( Index i = 0; i < NumVar; i++ )
   lmb[ i ] = 0; /*
   lmb[0]  =  11.19; lmb[1]  =  127.2; lmb[2]  = -129.7; lmb[3]  =  344.5;
   lmb[4]  = -40.72; lmb[5]  = -295.3; lmb[6]  = -202.3; lmb[7]  = -382.3;
   lmb[8]  = -217.7; lmb[9]  = -307.7; lmb[10] =  178.1; lmb[11] =  -4.36;
   lmb[12] = -123.3; lmb[13] = -265.3; lmb[14] =  28.28; lmb[15] =  70.57;
   lmb[16] = -31.81; lmb[17] = -222.3; lmb[18] =  96.19; lmb[19] = -52.79;
   lmb[20] = -34.71; lmb[21] = -59.16; lmb[22] = -373.7; lmb[23] = -28.35;
   lmb[24] = -141.7; lmb[25] =   2.28; lmb[26] =  198.5; lmb[27] = -69.16;
   lmb[28] = -26.35; lmb[29] = -88.72; lmb[30] =  130.8; lmb[31] = -12.35;
   lmb[32] =  -30.7; lmb[33] = -376.3; lmb[34] =  23.18; lmb[35] = -400.3;
   lmb[36] =  197.1; lmb[37] = -260.3; lmb[38] =  813.5; lmb[39] = -191.7;
   lmb[40] =  31.29; lmb[41] =  345.5; lmb[42] =  -7.72; lmb[43] =  335.5;
   lmb[44] =  947.5; lmb[45] =  722.5; lmb[46] = -300.3; lmb[47] =   73.2; */
   break;
  // Colville1   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 17 ):
   lmb[ 0 ] = 0;  lmb[ 1 ] = 0;  lmb[ 2 ] = 0;  lmb[ 3 ] = 0;  lmb[ 4 ] = 1;
   break;
  // HS78    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 18 ):
   lmb[ 0 ] = -2;  lmb[ 1 ] = 1.5;  lmb[ 2 ] = 2;
   lmb[ 3 ] = -1;  lmb[ 4 ] = -1;
   break;
  // El-Attar    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 19 ):
   lmb[ 0 ] = 2;  lmb[ 1 ] = 2;  lmb[ 2 ] = 7;
   lmb[ 4 ] = 0;  lmb[ 5 ] = -2; lmb[ 6 ] = 1;
   break;
  // Gill  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 20 ):
   for ( Index i = 0; i < NumVar; i++ )
    lmb[ i ] = -0.1;
   break;
  // Steiner2  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 21 ):
   for ( Index i = 0; i < NumVar; i++ )
  	lmb[ i ] = 0;
   break;
  // Goffin  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 22 ):
   for ( Index i = 0; i < NumVar; i++ )
	lmb[ i ] = ( i+1 ) - 25.5;
   break;
  // MXHILB    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 23 ):
   for ( Index i = 0; i < NumVar; i++ )
	lmb[ i ] = 1;
   break;
  // L1HILB    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 24 ):
   for ( Index i = 0; i < NumVar; i++ )
	lmb[ i ] = 1;
   break;
  // Shell Dual  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 25 ):
   for ( Index i = 0; i < NumVar; i++ )
	if( i != 6 )
	 lmb[ i ] = 1e-4;
   lmb[ 6 ] = 60;
   break;
  // smooth    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 26 ):
   for( Index i = 0; i < NumVar; i++ )
	lmb[ i ] = 1.0;
   break;
  // AbsVal    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 27 ):
   for( Index i = 0; i < NumVar; i++ )
   	lmb[ i ] = -1.0;
   break;
  // MaxQR    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 28 ):
   for( Index i = 0; i < NumVar; i++ )
    lmb[ i ] = 1.0;
   break;
  // Lewis  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 29 ):
   lmb[ 0 ] = -10; lmb[ 1 ] = -10;
   break;
  }  // end( switch )
 }  // end( LukFiOrcl::GetInitialPoint )

/*--------------------------------------------------------------------------*/
/*------------------------ METHODS FOR COMPUTING Fi() ----------------------*/
/*--------------------------------------------------------------------------*/

HpNum LukFiOrcl::Fi( cIndex wFi )
{
 if( ! wFi )     // 0-th component
  return( 0 );   // there is no such thing

 HpNum FiVal = 0;      // value of Fi()
 HpRow FiVal_ = NULL;

 LMRow tempL = NULL;

 double A16[ 5 ][ 10 ][ 10 ];
 double b16[ 5 ][ 10 ];

 switch( NameF ) {
  // Rosenbrock  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 1 ):
   FiVal = double(100) * ( Lambda[1] - Lambda[0] * Lambda[0] ) *
     ( Lambda[1] - Lambda[0] * Lambda[0] ) + ( double(1) - Lambda[0] )
     * ( double(1) - Lambda[0] );
   break;
  // Crescent  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 2 ):
   FiVal = std::max( Lambda[0] * Lambda[0] + ( Lambda[1] - double(1) )
	 * ( Lambda[1] - double(1) ) + Lambda[1] - double(1) ,
     - Lambda[0] * Lambda[0] - ( Lambda[1] - double(1) )
     * ( Lambda[1] - double(1) ) +  Lambda[1] + double(1) );
   break;
  // CB2 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 3 ):
   FiVal_= new double[3];
   FiVal_[0] = Lambda[0] * Lambda[0] + std::pow( HpNum(Lambda[1]) , 4 );
   FiVal_[1] = ( double(2) - Lambda[0] ) * ( double(2) - Lambda[0] )
     + ( double(2) - Lambda[1] ) * ( double(2) - Lambda[1] );
   FiVal_[2] = double(2) * exp ( - Lambda[0] + Lambda[1] );
   FiVal = MaxVecV( FiVal_, 3 );
   break;
  // CB3 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 4 ):
   FiVal_= new double[3];
   FiVal_[0] = std::pow( Lambda[0] , 4 ) + Lambda[1] * Lambda[1];
   FiVal_[1] = ( double(2) - Lambda[0] ) * ( double(2) - Lambda[0] )
	 + ( double(2) - Lambda[1] ) * ( double(2) - Lambda[1] );
   FiVal_[2] = double(2) * exp ( - Lambda[0] + Lambda[1] );
   FiVal = MaxVecV( FiVal_, 3 );
   break;
  // DEM - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 5 ):
   FiVal_= new double[3];
   FiVal_[0] = double(5) * Lambda[0] + Lambda[1];
   FiVal_[1] = - double(5) * Lambda[0] + Lambda[1];
   FiVal_[2] = Lambda[0] * Lambda[0] + Lambda[1] * Lambda[1]
	 + double(4) * Lambda[1];
   FiVal = MaxVecV( FiVal_, 3 );
   break;
  // QL  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 6 ):
   FiVal_= new double[3];
   FiVal_[0] = Lambda[0] * Lambda[0]  + Lambda[1] * Lambda[1];
   FiVal_[1] = FiVal_[0]
	 + double(10) * ( - double(4) * Lambda[0] - Lambda[1] + double(4) );
   FiVal_[2] = FiVal_[0]
     + double(10) * ( - Lambda[0] - double(2) * Lambda[1] + double(6) );
   FiVal = MaxVecV( FiVal_, 3 );
   break;
  // LQ  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 7 ):
   FiVal = std::max( - Lambda[0] - Lambda[1] , - Lambda[0] - Lambda[1]
     + Lambda[0] * Lambda[0] + Lambda[1] * Lambda[1] - double(1) );
   break;
  // Mifflin 1 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 8 ):
   FiVal =  - Lambda[0] + double(20) * std::max( Lambda[0] * Lambda[0]
	 + Lambda[1] * Lambda[1] - double(1) , double(0) );
   break;
  // Mifflin 2 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 9 ):
   FiVal = - Lambda[0] + double(2) * ( Lambda[0] * Lambda[0] + Lambda[1]
     * Lambda[1] - double(1) ) + double(1.75) * ABS( Lambda[0] * Lambda[0]
     + Lambda[1] * Lambda[1]  - double(1) );
   break;
  // Wolfe - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 10 ):
   if( Lambda[0] >= ABS( Lambda[1] ) )
	FiVal = double(5) * std::sqrt( double(9) * Lambda[0] * Lambda[0]
	  + double(16) * Lambda[1] * Lambda[1] );
   else
    if( Lambda[0] < ABS( Lambda[1] ) &&  Lambda[0] > double(0) )
     FiVal = double(9) * Lambda[0] + double(16) * ABS( Lambda[1] );
    else
     FiVal = double(9) * Lambda[0] + double(16) * ABS( Lambda[1] )
       - std::pow( Lambda[0] , 9 );
   break;
  // Rosen   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 11 ):
   FiVal_= new double[8];
   FiVal_[4] = Lambda[0] * Lambda[0]  + Lambda[1] * Lambda[1] + double(2)
	 * Lambda[2] * Lambda[2] + Lambda[3] * Lambda[3] - double(5) * Lambda[0]
	 - double(5) * Lambda[1] - double(21) * Lambda[2] + double(7) * Lambda[3];
   FiVal_[5] = Lambda[0] * Lambda[0] + Lambda[1] * Lambda[1] +  Lambda[2]
	 * Lambda[2] + Lambda[3] * Lambda[3] + Lambda[0] - Lambda[1] + Lambda[2]
     - Lambda[3] - double(8);
   FiVal_[6] = Lambda[0] * Lambda[0] + double(2) * Lambda[1] * Lambda[1]
	 + Lambda[2] * Lambda[2]  + double(2) * Lambda[3] * Lambda[3] - Lambda[0]
	 - Lambda[3] - double(10);
   FiVal_[7] = Lambda[0] * Lambda[0] + Lambda[1] * Lambda[1] +  Lambda[2]
	 * Lambda[2] + double(2) * Lambda[0] - Lambda[1] - Lambda[3] - double(5);
   FiVal_[0] = FiVal_[4];
   FiVal_[1] = FiVal_[4] + double(10) * FiVal_[5];
   FiVal_[2] = FiVal_[4] + double(10) * FiVal_[6];
   FiVal_[3] = FiVal_[4] + double(10) * FiVal_[7];
   FiVal = MaxVecV( FiVal_,  4 );
   break;
  // Shor  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 12 ):
   FiVal_= new double[10];
   for ( Index i = 0; i < 10; i++ ) {
    FiVal_[i] = 0;
    for ( Index j = 0; j < 5; j++ )
     FiVal_[i] += b12[ i ] * ( Lambda[ j ] - A12[ i ][ j ] )
       * ( Lambda[ j ] - A12[ i ][ j ] );
    }
   FiVal = MaxVecV( FiVal_,  10 );
   break;
  // Maxquad - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 13 ):
   for( Index i = 1; i <= 5 ; i ++ )
    for( Index j = 1; j <= 10 ; j++ ) {
     for( Index k = j + 1; k <= 10; k++ ) {
      A16[ i -1 ][ j -1  ][ k - 1 ] = exp( double( j ) / double( k ) )
        * cos( j * k ) * sin( i );
      A16[ i - 1 ][ k - 1 ][ j - 1 ] = A16[ i -1 ][ j -1  ][ k - 1 ];
      }
     A16[ i - 1 ][ j - 1 ][ j - 1 ] = ( double( j ) / double( 10 ) )
       * ABS( sin( i ) );
     for( Index k = 1; k <= 10; k++ )
      if( j != k )
       A16[ i - 1 ][ j - 1 ][ j - 1 ] += ABS( A16[ i - 1 ][ j - 1 ][ k - 1 ] );
     }
   for( Index i = 1; i <= 5; i++ )
    for( Index j = 1; j <= 10; j++ )
     b16[ i - 1 ][ j - 1 ] = exp( double( j ) / double(i) ) * sin( i * j );
   //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   FiVal_= new double[5];
   for( Index i = 0; i < 5 ; i++ ) {
    FiVal_[i] = 0;
    for( Index k = 0; k < 10; k++ )
     FiVal_[i] += Lambda[ k ] * ScalarProduct( A16[ i ][ k ], Lambda , 10 );
    FiVal_[i] -= ScalarProduct( b16[ i ] , Lambda , 10 );
    }
   FiVal = MaxVecV( FiVal_, 5 );
   break;
  // Maxq  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 14 ):
   FiVal_= new double[ 20 ];
   for( Index i = 0; i < 20; i++ )
    FiVal_[ i ] = Lambda[ i ] * Lambda[ i ];
   FiVal = MaxVecV( FiVal_, 20 );
   break;
  // Maxl  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 15 ):
   FiVal_= new double[ 20 ];
   for( Index i = 0; i < 20; i++ )
    FiVal_[ i ] = ABS( Lambda[ i ] );
   FiVal = MaxVecV( FiVal_, 20 );
   break;
  // TR48  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 16 ):
   FiVal_= new double[ 48 ];
   for( Index j = 0; j < 48; j++ ) {
    for( Index i = 0; i < 48; i++ )
     FiVal_[ i ] = Lambda[ i ] - A21[ i ][ j ];
    FiVal += MaxVecV( FiVal_,  48 ) * d21[ j ];
    }
   FiVal -= ScalarProduct( s21 , Lambda, 48  );
   break;
  // Colville 1  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 17 ):
   FiVal = ScalarProduct( e13 , Lambda , 5 );
   for ( Index j = 0; j < 5; j++)
    FiVal += d13[j] * Lambda[j] * Lambda[j] * Lambda[j];
   for ( Index i = 0; i < 5; i++)
    FiVal += Lambda[i] * ScalarProduct( C13[ i ] , Lambda , 5 );
   FiVal_= new double[10];
   for ( Index i = 0; i < 10; i++ )
    FiVal_[i] = b13[i] - ScalarProduct( A13[ i ] , Lambda , 5 );
   FiVal += double(50) * std::max( double(0) , MaxVecV( FiVal_,  10 ) );
   break;
  // HS78 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 18 ):
   FiVal_= new HpNum[3];
   FiVal_[0] = Lambda[0] * Lambda[0] + Lambda[1] * Lambda[1]
                + Lambda[2] * Lambda[2] + Lambda[3] * Lambda[3]
                + Lambda[4] * Lambda[4]  - double(10);
   FiVal_[1] =  Lambda[1] * Lambda[2]
                 - double(5) * Lambda[3] * Lambda[4];
   FiVal_[2] = Lambda[0] * Lambda[0] * Lambda[0]  +
		       Lambda[1] * Lambda[1] * Lambda[1]  + double(1) ;
   FiVal = double(10) * ( ABS(FiVal_[0]) + ABS(FiVal_[1]) + ABS(FiVal_[2]) );
   FiVal += Lambda[0] * Lambda[1] * Lambda[2] * Lambda[3] * Lambda[4] ;
   break;
  // Gill  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 20 ):
   FiVal_= new HpNum[3];
   FiVal_[0] = 0;
   for ( Index i = 0; i < NumVar; i++ )
    FiVal_[0] += ( Lambda[i] - double(1) ) * ( Lambda[i] - double(1) ) +
                1e-3 * ( Lambda[i] * Lambda[i] - 0.25 ) *
                ( Lambda[i] * Lambda[i] - 0.25 );
   FiVal_[1] = Lambda[0] * Lambda[0] + ( Lambda[1] - Lambda[0] * Lambda[0] - 1.0 )
		   * ( Lambda[1] - Lambda[0] * Lambda[0] - 1.0 );
   double FiVal1;
   double FiVal2;
   for ( Index i = 1; i < 30; i++ ) {
    FiVal1 = 0;
    FiVal2 = 0;
    for( Index j = 0; j < NumVar; j++ ) {
     FiVal2 += Lambda[j] * ( j ) * std::pow( ( HpNum(i) / 29) , j-1 );
     FiVal1 += Lambda[j] * std::pow( ( HpNum(i) / 29) , j );
     }
    FiVal2 -=  FiVal1 * FiVal1 +  double(1);
    FiVal_[1] += FiVal2 * FiVal2;
    }
   FiVal_[2] = 0;
   for( Index i = 1; i < NumVar; i++ )
    FiVal_[2] += double(100) * ( Lambda[i] - Lambda[i-1] * Lambda[i-1] ) *
      ( Lambda[i] - Lambda[i-1] * Lambda[i-1] )
      + ( 1.0 - Lambda[i] ) * ( 1.0 - Lambda[i] );
   FiVal = MaxVecV( FiVal_, 3 );
   break;
  // Goffin  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 22 ):
   FiVal_= new HpNum[NumVar];
   for ( Index i = 0; i < NumVar; i++ )
	FiVal_[i] =  HpNum(Lambda[i]);
   FiVal = HpNum(50) * MaxVecV( FiVal_, NumVar ) - SumV( FiVal_, NumVar );
   break;
  // MXHILB  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 23 ):
   FiVal_= new HpNum[NumVar];
   for( Index i = 0; i < NumVar; i++ ) {
	FiVal_[i] = HpNum(0);
    for ( Index j = 0; j < NumVar; j++ )
     FiVal_[i] += HpNum(Lambda[j]) / ( (i+1) + (j+1) -1 );
    FiVal_[i] = ABS(FiVal_[i]);
	}
   FiVal = MaxVecV( FiVal_, NumVar );
   break;
  // L1HILB  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 24 ):
   FiVal_= new HpNum[NumVar];
   for ( Index i = 0; i < NumVar; i++ ) {
	FiVal_[i] = HpNum(0);
	for ( Index j = 0; j < NumVar; j++ )
	 FiVal_[i] += HpNum(Lambda[j]) / ( (i+1) + (j+1) -1 );
	FiVal_[i] = ABS(FiVal_[i]);
	}
   FiVal = SumV( FiVal_, NumVar );
   break;
  // smooth  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 26 ):
   for( Index i = 0; i < NumVar; i++ )
	FiVal +=  0.5 * Lambda[ i ] *  Lambda[ i ];
   break;
  // AbsVal  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 27 ):
   for( Index i = 0; i < NumVar; i++ )
   	FiVal +=  ABS( Lambda[ i ] );
   break;
  // MaxQR   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 28 ):

   tempL = new LMNum[ NumVar ];

   FiVal_= new double[ NrCmp ];
   for( Index j = 0; j < NrCmp; j++ ) {
	VectDiff( tempL , Lambda , cQR[ j ] , NumVar );
	FiVal_[ j ] = bQR[ j ] * Norm( tempL , NumVar );
	FiVal_[ j ] += aQR[ j ];
    }
   FiVal = MaxVecV( FiVal_, NrCmp );
   break;
  // Lewis  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 29 ):
   if( Lambda[ 1 ] <= 0)
	FiVal = Lambda[ 0 ] * Lambda[ 0 ] - Lambda[ 1 ];
   if( Lambda[ 1 ] > 0 && Lambda[ 1 ] < Lambda[ 0 ] * Lambda[ 0 ] )
	FiVal = Lambda[ 0 ] * Lambda[ 0 ] +  Lambda[ 1 ];
   if( Lambda[ 0 ] * Lambda[ 0 ] > 0 && Lambda[ 0 ] * Lambda[ 0 ] <= Lambda[ 1 ]
      &&  Lambda[ 1 ] <= 4.0 * Lambda[ 0 ] * Lambda[ 0 ] )
	FiVal = 3.0 *  Lambda[ 0 ] * Lambda[ 0 ]  - Lambda[ 1 ];
   if( Lambda[ 1 ] > 4.0 * Lambda[ 0 ] * Lambda[ 0 ] )
	FiVal = - 5.0 * Lambda[ 0 ] * Lambda[ 0 ] + Lambda[ 1 ];
   break;
  }

 delete[] FiVal_;
 delete[] tempL;

 return( FiVal );

 }  // end( LukFiOrcl::Fi )

/*--------------------------------------------------------------------------*/
/*------------- METHODS FOR READING SUBGRADIENTS / CONSTRAINTS -------------*/
/*--------------------------------------------------------------------------*/

Index LukFiOrcl::GetGi( SgRow SubG , cIndex_Set &SGBse , cIndex Name ,
			cIndex strt , Index stp )
{
 if( Name < MaxName )
  throw( NDOException( "LukFiOrcl::GetGi: The required information"
		       " about previous items does not accepted" ) );

 if( Name == MaxName ) {
  // no 0-th component == all-0 one
  SGBse = &EmptySg;
  return( 0 );
  }

 // auxiliary variables

 HpRow FiVal_ = NULL;
 Index FIndex = 0;

 LMRow tempL = NULL;

 double A16[ 5 ][ 10 ][ 10 ];
 double b16[ 5 ][ 10 ];


 // SubG is always in "dense" format

 SGBse = NULL;

 for ( Index i=0; i < NumVar; i++)
  SubG[i] = 0;

 if( Name > MaxName ) {

  switch( NameF ) {
   // Rosenbrock  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case ( 1 ):
    SubG[1] = double(200) * ( Lambda[1] - Lambda[0] * Lambda[0] );
    SubG[0] = double(2) * Lambda[0] * ( double(1) - SubG[1] ) - double(2);
    break;
   // Crescent    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case ( 2 ):
    FiVal_= new double[2];
    FiVal_[0] = Lambda[0] * Lambda[0]  + ( Lambda[1] - double(1) )
      * ( Lambda[1] - double(1) ) + Lambda[1] - double(1);
    FiVal_[1] = - Lambda[0] * Lambda[0] - ( Lambda[1] - double(1) )
      * ( Lambda[1] - double(1) ) +  Lambda[1] + double(1);
    FIndex = MaxVecI( FiVal_, 2 );
    //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if (FIndex == 0) {
	 SubG[0] = double(2) * Lambda[0];
     SubG[1] = double(2) * ( Lambda[1] - double(1) ) + double(1);
     }
    else {
	 SubG[0] = - double(2) * Lambda[0];
	 SubG[1] = - double(2) * ( Lambda[1] - double(1) ) + double(1);
	 }
    break;
   // CB2   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case ( 3 ):
    FiVal_= new double[3];
    FiVal_[0] = Lambda[0] * Lambda[0] + std::pow( Lambda[1] , 4 );
    FiVal_[1] = ( double(2) - Lambda[0] ) * ( double(2) - Lambda[0] )
	  + ( double(2) - Lambda[1] ) * ( double(2) - Lambda[1] );
    FiVal_[2] = double(2) * exp ( - Lambda[0] + Lambda[1] );
    FIndex = MaxVecI( FiVal_, 3 );
    //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if (FIndex == 0) {
     SubG[0] = double(2) * Lambda[0];
     SubG[1] = double(4) * std::pow( Lambda[1] , 3 );
	 }
    else
     if (FIndex == 1) {
      SubG[0] = - double(2) * ( double(2) - Lambda[0] );
      SubG[1] = - double(2) * ( double(2) - Lambda[1] );
	  }
	 else {
	  SubG[0] = - double(2) * exp ( - Lambda[0] + Lambda[1] );
	  SubG[1] = double(2) * exp ( - Lambda[0] + Lambda[1] );
	  }
    break;
   // CB3   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case ( 4 ):
    FiVal_= new double[3];
    FiVal_[0] = std::pow( Lambda[0] , 4 ) + Lambda[1] * Lambda[1];
    FiVal_[1] = ( double(2) - Lambda[0] ) * ( double(2) - Lambda[0] )
      + ( double(2) - Lambda[1] ) * ( double(2) - Lambda[1] );
    FiVal_[2] = double(2) * exp ( - Lambda[0] + Lambda[1] );
    FIndex = MaxVecI( FiVal_, 3 );
    //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if (FIndex == 0) {
	 SubG[0] = double(4) * std::pow( Lambda[0] , 3 );
     SubG[1] = double(2) * Lambda[1];
     }
    else
     if (FIndex == 1) {
	  SubG[0] = - double(2) * ( double(2) - Lambda[0] );
	  SubG[1] = - double(2) * ( double(2) - Lambda[1] );
	  }
     else {
	  SubG[0] = -double(2) * exp ( - Lambda[0] + Lambda[1] );
	  SubG[1] = double(2) * exp ( - Lambda[0] + Lambda[1] );
	  }
    break;
   // DEM   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case ( 5 ):
    FiVal_= new double[3];
    FiVal_[0] = double(5) * Lambda[0] + Lambda[1];
    FiVal_[1] = - double(5) * Lambda[0] + Lambda[1];
    FiVal_[2] = Lambda[0] * Lambda[0] +  Lambda[1] * Lambda[1]
      + double(4) * Lambda[1];
    FIndex  = MaxVecI( FiVal_, 3 );
    //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if (FIndex == 0) {
	 SubG[0] = 5;
	 SubG[1] = 1;
	 }
    else
	 if (FIndex == 1) {
	  SubG[0] = - 5;
	  SubG[1] = 1;
	  }
	 else {
	  SubG[0] = double(2) * Lambda[0];
	  SubG[1] = double(2) * Lambda[1] + double(4);
	  }
    break;
   // QL    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case ( 6 ):
    FiVal_= new double[3];
    FiVal_[0] = Lambda[0] * Lambda[0] + Lambda[1] * Lambda[1];
    FiVal_[1] = FiVal_[0]
   	 + double(10) * ( - double(4) * Lambda[0] - Lambda[1] + double(4) );
    FiVal_[2] = FiVal_[0]
	  + double(10) * ( - Lambda[0] - double(2) * Lambda[1] + double(6) );
    FIndex = MaxVecI( FiVal_, 3 );
    //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    SubG[0] = double(2) * Lambda[0];
    SubG[1] = double(2) * Lambda[1];
    if (FIndex == 1) {
     SubG[0] -= 40;
     SubG[1] -= 10;
     }
    else
     if (FIndex == 2) {
	  SubG[0] -= 10;
	  SubG[1] -= 20;
	  }
    break;
   // LQ  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case ( 7 ):
    FiVal_= new double[2];
    FiVal_[0] = - Lambda[0] - Lambda[1];
    FiVal_[1] = - Lambda[0] - Lambda[1] + ( Lambda[0] * Lambda[0]
      + Lambda[1] * Lambda[1] - double(1) );
    FIndex = MaxVecI( FiVal_, 2 );
    //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    SubG[0] = - 1;
    SubG[1] = - 1;
    if (FIndex == 1) {
	 SubG[0] += double(2) * Lambda[0];
	 SubG[1] += double(2) * Lambda[1];
	 }
    break;
   // Mifflin 1 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case ( 8 ):
    FiVal_= new double[2];
    FiVal_[0] = Lambda[0] * Lambda[0]  + Lambda[1] * Lambda[1] - double(1);
    FiVal_[1] = 0;
    FIndex = MaxVecI( FiVal_, 2 );
    //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    SubG[0] = - 1;
    SubG[1] =  0;
    if (FIndex == 0) {
     SubG[0] += double(40) * Lambda[0];
     SubG[1] += double(40) * Lambda[1];
     }
    break;
   // Mifflin 2 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case ( 9 ):
    FiVal_= new double[2];
    FiVal_[0] = Lambda[0] * Lambda[0] + Lambda[1] * Lambda[1] - double(1);
    FiVal_[1] = - Lambda[0] * Lambda[0] - Lambda[1] * Lambda[1] + double(1);
    FIndex = MaxVecI( FiVal_, 2 );
    //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    SubG[0] = -double(1) + double(4) * Lambda[0];
    SubG[1] =  double(4) * Lambda[1];
    if (FIndex == 0) {
     SubG[0] += double(3.5) * Lambda[0];
     SubG[1] += double(3.5) * Lambda[1];
     }
    else {
     SubG[0] -= double(3.5) * Lambda[0];
     SubG[1] -= double(3.5) * Lambda[1];
     }
    break;
   // Wolfe   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case ( 10 ):
    if( Lambda[0] >= ABS( Lambda[1] ) ) {
  	 SubG[0] = double(45) * Lambda[0] /
	           std::sqrt( double(9) * Lambda[0] * Lambda[0]
  	   + double(16) * Lambda[1] * Lambda[1] );
     SubG[1] = double(80) * Lambda[1] /
               std::sqrt( double(9) * Lambda[0] * Lambda[0]
			  + double(16) * Lambda[1] * Lambda[1] );
  	 }
    else
     if ( Lambda[0] < ABS( Lambda[1] ) &&  Lambda[0] > double(0) ) {
      SubG[0] = double(9) * Lambda[0];
      SubG[1] = double(16) * ( Lambda[1] >= double(0)? double(1): -double(1) );
      }
     else {
      SubG[0] = double(9) * ( double(1) - std::pow( Lambda[0] , 8 ) );
      SubG[1] = double(16) * ( Lambda[1] >= double(0)? double(1): -double(1) );
      }
    break;
   // Rosen   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case ( 11 ):
    FiVal_= new double[8];
    FiVal_[4] = Lambda[0] * Lambda[0]  + Lambda[1] * Lambda[1] + double(2)
	 * Lambda[2] * Lambda[2] + Lambda[3] * Lambda[3] - double(5) * Lambda[0]
	 - double(5) * Lambda[1] - double(21) * Lambda[2] + double(7) * Lambda[3];
    FiVal_[5] = Lambda[0] * Lambda[0] + Lambda[1] * Lambda[1] +  Lambda[2]
	  * Lambda[2] + Lambda[3] * Lambda[3] + Lambda[0] - Lambda[1] + Lambda[2]
      - Lambda[3] - double(8);
    FiVal_[6] = Lambda[0] * Lambda[0] + double(2) * Lambda[1] * Lambda[1]
	  + Lambda[2] * Lambda[2]  + double(2) * Lambda[3] * Lambda[3] - Lambda[0]
	  - Lambda[3] - double(10);
    FiVal_[7] = Lambda[0] * Lambda[0] + Lambda[1] * Lambda[1] +  Lambda[2]
	  * Lambda[2] + double(2) * Lambda[0] - Lambda[1] - Lambda[3] - double(5);
    FiVal_[0] = FiVal_[4];
    FiVal_[1] = FiVal_[4] + double(10) * FiVal_[5];
    FiVal_[2] = FiVal_[4] + double(10) * FiVal_[6];
    FiVal_[3] = FiVal_[4] + double(10) * FiVal_[7];
    FIndex = MaxVecI( FiVal_, 4 );
    //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    SubG[0] = double(2) * Lambda[0] - double(5);
    SubG[1] = double(2) * Lambda[1] - double(5);
    SubG[2] = double(4) * Lambda[2] - double(21);
    SubG[3] = double(2) * Lambda[3] + double(7);
    if (FIndex == 1) {
	 SubG[0] += double(10) * ( double(2) * Lambda[0] + double(1) );
	 SubG[1] += double(10) * ( double(2) * Lambda[1] - double(1) );
	 SubG[2] += double(10) * ( double(2) * Lambda[2] + double(1) );
	 SubG[3] += double(10) * ( double(2) * Lambda[3] - double(1) );
	 }
    else
	 if (FIndex == 2) {
      SubG[0] += double(10) * ( double(2) * Lambda[0] - double(1) );
      SubG[1] += double(40) * Lambda[1];
      SubG[2] += double(20) * Lambda[2];
      SubG[3] += double(10) * ( double(4) * Lambda[3] - double(1) );
	  }
	 else
	  if (FIndex == 3) {
	   SubG[0] += double(10) * ( double(2) * Lambda[0] + double(2) );
	   SubG[1] += double(10) * ( double(2) * Lambda[1] - double(1) );
	   SubG[2] += double(20) * Lambda[2];
	   SubG[3] -= double(10);
	   }
    break;
   // Shor  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case ( 12 ):
    FiVal_= new double[10];
    for( Index i = 0; i < 10; i++ ) {
     FiVal_[i] = 0;
     for( Index j = 0; j < 5; j++ )
      FiVal_[i] += b12[ i ] * ( Lambda[ j ] - A12[ i ][ j ] )
        * ( Lambda[ j ] - A12[ i ][ j ] );
     }
    FIndex = MaxVecI( FiVal_,  10 );
    for ( Index j = 0; j < 5; j++ )
     SubG[j] = double(2) * b12[ FIndex ] * ( Lambda[j] - A12[ FIndex ][ j ] );
    break;
   // Maxquad - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case ( 13 ):
    for( Index i = 1; i <= 5 ; i ++ )
     for( Index j = 1; j <= 10 ; j++ ) {
      for( Index k = j + 1; k <= 10; k++ ) {
       A16[ i -1 ][ j -1  ][ k - 1 ] = exp( double( j ) / double( k ) )
         * cos( j * k ) * sin( i );
       A16[ i - 1 ][ k - 1 ][ j - 1 ] = A16[ i -1 ][ j -1  ][ k - 1 ];
       }
      A16[ i - 1 ][ j - 1 ][ j - 1 ] = ( double( j ) / double( 10 ) )
        * ABS( sin( i ) );
      for( Index k = 1; k <= 10; k++ )
       if( j != k )
        A16[ i - 1 ][ j - 1 ][ j - 1 ] += ABS( A16[ i - 1 ][ j - 1 ][ k - 1 ] );
      }
    for( Index i = 1; i <= 5; i++ )
     for( Index j = 1; j <= 10; j++ )
      b16[ i - 1 ][ j - 1 ] = exp( double( j ) / double(i) ) * sin( i * j );
    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    FiVal_= new double[5];
    for( Index i = 0; i < 5 ; i++ ) {
     FiVal_[i] = 0;
     for( Index k = 0; k < 10; k++ )
      FiVal_[i] += Lambda[ k ] * ScalarProduct( A16[ i ][ k ], Lambda , 10 );
     FiVal_[i] -= ScalarProduct( b16[ i ] , Lambda , 10 );
     }
    FIndex = MaxVecI( FiVal_, 5 );
    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    for ( Index k = 0; k < 10 ; k ++ )
     SubG[k] = double( 2 ) * ScalarProduct( A16[ FIndex ][ k ] , Lambda , 10 )
       - b16[ FIndex ][ k ];
    break;
   // Maxq  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case ( 14 ):
    FiVal_= new double[ 20 ];
    for( Index i = 0; i < 20; i++ )
     FiVal_[i] = Lambda[i] * Lambda[i];
    FIndex = MaxVecI( FiVal_, 20 );
    SubG[ FIndex ] = double(2) * Lambda[ FIndex ];
    break;
   // Maxl  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case ( 15 ):
    FiVal_= new double[ 20 ];
    for ( Index i = 0; i < 20; i++ )
     FiVal_[ i ] = ABS( Lambda[ i ] );
    FIndex = MaxVecI( FiVal_, 20 );
    SubG[FIndex] = ( Lambda[FIndex] >= double(0) )? double(1): - double(1);
    break;
   // TR48  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case ( 16 ):
    FiVal_= new double[ 48 ];
    for( Index j = 0; j < 48; j++ ) {
     for( Index i = 0; i < 48 ; i++ )
      FiVal_[ i ] = Lambda[ i ] - A21[ i ][ j ];
     FIndex = MaxVecI( FiVal_,  48 );
     SubG[ FIndex ] += d21[ j ];
     SubG[ j ] -= s21[ j ];
     }
    break;
   // Colville 1  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 17 ):
   FiVal_= new HpNum[10];
   for( Index i = 0; i < 10; i++ )
    FiVal_[i] = b13[i] - ScalarProduct( A13[ i ] , Lambda , 5 );
   FIndex = MaxVecI( FiVal_,  10 );
   for ( Index j = 0; j < 5; j++ )
    SubG[j] = double(3) * d13[j] * Lambda[j] * Lambda[j] + e13[j]
         + double(2) * ScalarProduct( C13[j] , Lambda , 5 );
   if( FiVal_[FIndex] >  double(0) )
   for ( Index j = 0; j < NumVar; j++ )
    SubG[j] += double(50) * A13[ FIndex ][ j ];
   break;
  // HS78  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 18 ):
   FiVal_= new HpNum[3];
   FiVal_[0] = std::pow( HpNum(Lambda[0]) , 2 ) + std::pow( HpNum(Lambda[1]) , 2 )
             + std::pow( HpNum(Lambda[2]) , 2 ) + std::pow( HpNum(Lambda[3]) , 2 )
             + std::pow( HpNum(Lambda[4]) , 2 ) - HpNum(10);
   FiVal_[1] = HpNum(Lambda[1]) * HpNum(Lambda[2])
                   - HpNum(5) * HpNum(Lambda[3]) * HpNum(Lambda[4]);
   FiVal_[2] = std::pow( HpNum(Lambda[0]) , 3 ) + std::pow( HpNum(Lambda[1]) , 3 ) + HpNum(1) ;
   SubG[0] = SgNum(Lambda[1]) * SgNum(Lambda[2])
                        *SgNum(Lambda[3]) * SgNum(Lambda[4]);
   SubG[1] = SgNum(Lambda[0]) * SgNum(Lambda[2])
                        *SgNum(Lambda[3]) * SgNum(Lambda[4]);
   SubG[2] = SgNum(Lambda[0]) * SgNum(Lambda[1])
                        *SgNum(Lambda[3]) * SgNum(Lambda[4]);
   SubG[3] = SgNum(Lambda[0]) * SgNum(Lambda[1])
                        *SgNum(Lambda[2]) * SgNum(Lambda[4]);
   SubG[4] = SgNum(Lambda[0]) * SgNum(Lambda[1])
                        *SgNum(Lambda[2]) * SgNum(Lambda[3]);
   if (FiVal_[0] == std::max( FiVal_[0], -FiVal_[0])) {
    SubG[0] += SgNum(20) * SgNum(Lambda[0]);
    SubG[1] += SgNum(20) * SgNum(Lambda[1]);
    SubG[2] += SgNum(20) * SgNum(Lambda[2]);
    SubG[3] += SgNum(20) * SgNum(Lambda[3]);
    SubG[4] += SgNum(20) * SgNum(Lambda[4]);
    }
   else {
    SubG[0] -= SgNum(20) * SgNum(Lambda[0]);
    SubG[1] -= SgNum(20) * SgNum(Lambda[1]);
    SubG[2] -= SgNum(20) * SgNum(Lambda[2]);
    SubG[3] -= SgNum(20) * SgNum(Lambda[3]);
    SubG[4] -= SgNum(20) * SgNum(Lambda[4]);
    }
   if( FiVal_[1] == std::max( FiVal_[1], -FiVal_[1]) ) {
    SubG[1] += SgNum(10) * SgNum(Lambda[2]);
    SubG[2] += SgNum(10) * SgNum(Lambda[1]);
    SubG[3] -= SgNum(50) * SgNum(Lambda[4]);
    SubG[4] -= SgNum(50) * SgNum(Lambda[3]);
    }
   else {
    SubG[1] -= SgNum(10) * SgNum(Lambda[2]);
    SubG[2] -= SgNum(10) * SgNum(Lambda[1]);
    SubG[3] += SgNum(50) * SgNum(Lambda[4]);
    SubG[4] += SgNum(50) * SgNum(Lambda[3]);
    }
   if( FiVal_[2] == std::max( FiVal_[2], -FiVal_[2]) ) {
    SubG[0] += SgNum(30) * std::pow( SgNum(Lambda[0]), 2);
    SubG[1] += SgNum(30) * std::pow( SgNum(Lambda[1]), 2);
    }
   else {
    SubG[0] -= SgNum(30) * std::pow( SgNum(Lambda[0]), 2);
    SubG[1] -= SgNum(30) * std::pow( SgNum(Lambda[1]), 2);
    }
   break;
  // Gill    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 20 ):
   FiVal_= new HpNum[3];
   FiVal_[0] = 0;
   for ( Index i = 0; i < NumVar; i++ )
    FiVal_[0] += std::pow( HpNum(Lambda[i]) - HpNum(1), 2 ) + HpNum(1e-3)
                    * std::pow( std::pow( HpNum(Lambda[i]) , 2 ) - HpNum(0.25), 2 );
   FiVal_[1] = std::pow( HpNum(Lambda[0]) , 2 ) + std::pow( HpNum(Lambda[1])
      	   	      - std::pow( HpNum(Lambda[0]) , 2 ) - HpNum(1) , 2);
   HpNum FiVal1;
   HpNum FiVal2;
   for( Index i = 1; i < 30; i++ ) {
    FiVal1 = 0;
    FiVal2 = 0;
    for( Index j = 0; j < NumVar; j++ ) {
     FiVal2 += HpNum(Lambda[j]) * ( j ) * std::pow( ( HpNum(i) / 29) , j-1 );
     FiVal1 += HpNum(Lambda[j]) * std::pow( ( HpNum(i) / 29) , j );
     }
    FiVal2 -=  std::pow( FiVal1 , 2 ) +  HpNum(1);
    FiVal_[1] += std::pow( FiVal2 , 2 );
    }
   FiVal_[2] = 0;
   for( Index i = 1; i < NumVar; i++ )
    FiVal_[2] += HpNum(100) * std::pow( HpNum(Lambda[i]) - std::pow( HpNum(Lambda[i-1]) , 2 ) , 2 )
                    + std::pow( HpNum(1) - HpNum(Lambda[i]) , 2 );
   FIndex = MaxVecI( FiVal_, 3 );
   if( FIndex == 0 )
    for( Index i = 0 ; i < NumVar; i++ )
       SubG[i] = HpNum(2) * ( HpNum(Lambda[i]) - HpNum(1) ) + HpNum(4e-3)
                         * std::pow( std::pow( HpNum(Lambda[i]) , 2 ) - HpNum(0.25), 2 )
                            * HpNum(Lambda[i]);
   else
    if( FIndex == 1 ) {
     SgNum GiVal1;
     for( Index i = 1; i < 30; i++ )
     for( Index j = 0; j < NumVar; j++ ) {
     SubG[j] = 0;
     GiVal1 = 0;
     for( Index k = 0; k < NumVar; k++ ) {
      GiVal1 += SgNum(Lambda[k]) * std::pow( ( SgNum(i) / 29) , k );
      SubG[j] += SgNum(Lambda[k]) * ( k ) * std::pow( ( SgNum(i) / 29 ) , k-1 );
      }
     SubG[j] -= std::pow( GiVal1 , 2 ) +  SgNum(1);
     SubG[j] *= SgNum(2) * ( SgNum(Lambda[j]) * ( j )
                             * std::pow( ( SgNum(i) / 29) , j-1 ) - SgNum(2)
                             * GiVal1 * std::pow( ( SgNum(i) / 29 ) , j-1 ) );
     }
    SubG[0] += SgNum(2) * SgNum(Lambda[0]) - SgNum(4) *
                    ( SgNum(Lambda[1]) - std::pow(SgNum(Lambda[0]),2) - SgNum(1) )
                           * SgNum(Lambda[0]);
    SubG[1] += SgNum(2) * ( SgNum(Lambda[1]) - std::pow(SgNum(Lambda[0]),2) - SgNum(1) );
    }
   else {
    for ( Index i = 1 ; i < NumVar ; i++ )
      SubG[i] += SgNum(200) * ( SgNum(Lambda[i]) - std::pow( SgNum(Lambda[i-1]),2 ) )
                 + SgNum(-2) * ( SgNum(1) - SgNum(Lambda[i]) ) - SgNum(400)
                 * ( SgNum(Lambda[i+1]) - std::pow( SgNum(Lambda[i]) , 2 ) ) *
                         SgNum(Lambda[i]);
    SubG[0] += - SgNum(400) * ( Lambda[1] - std::pow( Lambda[0] , 2 ) ) * Lambda[0];
    }
   break;
  // Goffin  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 22 ):
   FiVal_= new HpNum[NumVar];
   for ( Index i = 0; i < NumVar; i++ )
	FiVal_[i] =  HpNum(Lambda[i]);
   FIndex = MaxVecI( FiVal_, NumVar );
   SubG[FIndex] = SgNum(50);
   for ( Index i = 0; i < NumVar; i++ )
    SubG[i] -= HpNum(1);
   break;
  // MXHILB
  case ( 23 ): {
   FiVal_= new HpNum[NumVar];
   HpRow b = new HpNum[NumVar];
   for ( Index i = 0; i < NumVar; i++ ) {
    FiVal_[i] = HpNum(0);
    for ( Index j = 0; j < NumVar; j++ )
     FiVal_[i] += HpNum(Lambda[j]) / ( (i+1) + (j+1) -1 );
    if ( FiVal_[i] >= HpNum(0) )
     b[i] = HpNum(1);
    else
      b[i] = -HpNum(1);
    FiVal_[i] = ABS(FiVal_[i]);
    }
   FIndex = MaxVecI( FiVal_, NumVar );
   for ( Index j = 0; j < NumVar; j++ )
    SubG[j] = b[FIndex] / ( (FIndex+1) + (j+1) -1 );
   break;
   }
  // L1HILB
  case ( 24 ): {
   FiVal_= new HpNum[NumVar];
   HpRow b = new HpNum[NumVar];
   for( Index i = 0; i < NumVar; i++ ) {
    FiVal_[i] = HpNum(0);
    for ( Index j = 0; j < NumVar; j++ )
     FiVal_[i] += HpNum(Lambda[j]) / ( (i+1) + (j+1) -1 );
    if ( FiVal_[i] >= HpNum(0) )
     b[i] = HpNum(1);
    else
     b[i] = -HpNum(1);
    }
    for ( Index i = 0; i < NumVar; i++ )
     for ( Index j = 0; j < NumVar; j++ )
      SubG[j] += b[i] / ( (i+1) + (j+1) -1 );
    break;
   }
   // smooth  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case( 26 ):
    for( Index i = 0; i < NumVar ; i++ )
     SubG[ i ] = Lambda[ i ];
    break;
   // AbsVal   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case( 27 ):
    for( Index i = 0; i < NumVar ; i++ )
     if( Lambda[ i ] >= 0 )
      SubG[ i ] = 1;
     else
      SubG[ i ] = -1;
    break;
   // MaxQR   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case( 28 ):

    tempL = new LMNum[ NumVar ];

    FiVal_= new double[ NrCmp ];
    for( Index j = 0; j < NrCmp; j++ ) {
     VectDiff( tempL , Lambda , cQR[ j ] , NumVar );
     FiVal_[ j ] = bQR[ j ] * Norm( tempL , NumVar );
     FiVal_[ j ] += aQR[ j ];
     }
    FIndex = MaxVecI( FiVal_ , NrCmp );
    VectDiff( SubG , Lambda , cQR[ FIndex ] , NumVar );
    VectScale( SubG , 2.0 * bQR[ FIndex ] , NumVar );
    break;
   // Lewis  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case( 29 ):
    if( Lambda[ 1 ] <= 0) {
     SubG[ 0 ] = 2.0 * Lambda[ 0 ];
     SubG[ 1 ] = -1;
     }
    if( Lambda[ 1 ] > 0 && Lambda[ 1 ] < Lambda[ 0 ] * Lambda[ 0 ] ) {
     SubG[ 0 ] = 2.0 * Lambda[ 0 ];
     SubG[ 1 ] = 1;
     }
    if( Lambda[ 0 ] * Lambda[ 0 ] > 0 && Lambda[ 0 ] * Lambda[ 0 ] <= Lambda[ 1 ]
         &&  Lambda[ 1 ] <= 4.0 * Lambda[ 0 ] * Lambda[ 0 ] ) {
     SubG[ 0 ] = 6.0 * Lambda[ 0 ];
     SubG[ 1 ] = -1;
     }
    if( Lambda[ 1 ] > 4.0 * Lambda[ 0 ] * Lambda[ 0 ] ) {
     SubG[ 0 ] = -10.0 * Lambda[ 0 ];
     SubG[ 1 ] = 1;
     }
    break;
   }

 delete[] FiVal_;
 delete[] tempL;

 } // end (Name > MaxName )

 return( NumVar );

 } // end ( LukFiOrcl::GetGi )

/*--------------------------------------------------------------------------*/

HpNum LukFiOrcl::GetVal( cIndex Name )
{
 if( Name < MaxName )
  throw( NDOException( "LukFiOrcl::GetVal: The required "
		  "information about previous items does not accepted" ) );

 return( 0 );

 } // end ( LukFiOrcl::GetVal )

/*--------------------------------------------------------------------------*/
/*-------------------- METHODS FOR READING OTHER RESULTS -------------------*/
/*--------------------------------------------------------------------------*/

HpNum LukFiOrcl::GetLowerBound( cIndex wFi )
{
 switch( NameF ) {
  // Rosenbrock  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 1 ): break;
  // Crescent    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 2 ): break;
  // CB2 (Charalambous/Bandler)  - - - - - - - - - - - - - - - - - - - - - - -
  case( 3 ): return( 1.9522245 );
  // CB3 (Charalambous/Bandler)  - - - - - - - - - - - - - - - - - - - - - - -
  case( 4 ): return( 2 );
  // DEM (Demyanov/Malozemov)  - - - - - - - - - - - - - - - - - - - - - - - -
  case( 5 ): return( -3 );
  // QL    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 6 ): return( 7.2 );
  // LQ    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 7 ): return( -1.414213562373095 );
  // Mifflin1      - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 8 ): return( -1 );
  // Mifflin2      - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 9 ): return( -1 );
  // Wolfe   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 10 ): return( -8 );
  // Rosen-Suzuki    - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 11 ): return( -44 );
  // Shor    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 12 ): return( 22.60016 );
  // Maxquad   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 13 ): return( -0.8414084 );
  // Maxq    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 14 ): break;
  // Maxl    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 15 ): break;
  // TR48    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 16 ): return( -638565 );
  // Colville1   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 17 ): return( -32.348679 );
  // HS78  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 18 ): return( -2.9197004 );
  // El-Attar  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 19 ): return( -0.5598131 );
  // Gill  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 20 ): return( 9.7857721 );
  // Steiner2  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 21 ): return( 16.703838 );
  // Goffin  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 22 ): break;
  // MXHILB    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 23 ): break;
  // L1HILB    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 24 ): break;
  // Shell Dual  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 25 ): return( 32.348679 );
  // smooth - -  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 26 ): break;
   // AbsVal - -  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 27 ): break;
   // MaxQR - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 28 ): return( -Inf< HpNum >() );  // safe
   // Lewis - - = - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 29 ): return( -Inf< HpNum >() );  // safe
  }  // end( switch )

 return( 0 );
 }

/*------------------------------ DESTRUCTOR --------------------------------*/

LukFiOrcl::~LukFiOrcl()
{
 delete[] bQR;
 delete[] aQR;
 delete[] cQR;
 }

/*--------------------------------------------------------------------------*/

void LukFiOrcl::SetDimension( void )
{

 // set the dimension of the function  - - - - - - - - - - - - - - - - - - - -
 //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

 switch( NameF ) {
  // Rosenbrock  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 1 ):
   NumVar = Index (2);
   break;
  // Crescent    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 2 ):
   NumVar = Index (2);
   break;
  // CB2 (Charalambous/Bandler)  - - - - - - - - - - - - - - - - - - - - - - -
  case( 3 ):
   NumVar = Index (2);
   break;
  // CB3 (Charalambous/Bandler)  - - - - - - - - - - - - - - - - - - - - - - -
  case( 4 ):
   NumVar = Index (2);
   break;
  // DEM (Demyanov/Malozemov)  - - - - - - - - - - - - - - - - - - - - - - - -
  case( 5 ):
   NumVar = Index (2);
   break;
  // QL    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 6 ):
   NumVar = Index (2);
   break;
  // LQ    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 7 ):
   NumVar = Index (2);
   break;
  // Mifflin1      - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 8 ):
   NumVar = Index (2);
   break;
  // Mifflin2      - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 9 ):
   NumVar = Index (2);
   break;
  // Wolfe   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 10 ):
   NumVar = Index (2);
   break;
  // Rosen-Suzuki    - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 11 ):
   NumVar = Index (4);
   break;
  // Shor    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 12 ):
   NumVar = Index (5);
   break;
  // Maxquad   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 13 ):
   NumVar = Index (10);
   break;
  // Maxq    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 14 ):
   NumVar = Index (20);
   break;
  // Maxl    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 15 ):
   NumVar = Index (20);
   break;
  // TR48    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 16 ):
   NumVar = Index( 48 );
   break;
  // Colville1   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 17 ):
   NumVar = Index (5);
   break;
  // HS78  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 18 ):
   NumVar = Index (5);
   break;
  // El-Attar  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 19 ):
   NumVar = Index (6);
   break;
  // Gill  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 20 ):
   NumVar = Index (10);
   break;
  // Steiner2  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 21 ):
   NumVar = Index (12);
   break;
  // Goffin  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 22 ):
   NumVar = Index (50);
   break;
  // MXHILB    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 23 ):
   NumVar = Index (50);
   break;
  // L1HILB    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 24 ):
   NumVar = Index (50);
   break;
  // Shell Dual  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 25 ):
   NumVar = Index (15);
   break;
  // Lewis   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 29 ):
   NumVar = Index( 2 );
   break;
  }  // end( switch )
 }  // end( LukFiOrcl::SetDimension )

/*--------------------------------------------------------------------------*/
/*-------------------------- End File LukFiOrcl.C --------------------------*/
/*--------------------------------------------------------------------------*/
